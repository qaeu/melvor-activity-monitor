const{render:litRender,noChange:noChange,html:litHtml}=window.litHtml;let current,currentId=0;function setCurrent(t){current=t}function clear(){current=null,currentId=0}function notify(){return currentId++}const phaseSymbol=Symbol("haunted.phase"),hookSymbol=Symbol("haunted.hook"),updateSymbol=Symbol("haunted.update"),commitSymbol=Symbol("haunted.commit"),effectsSymbol=Symbol("haunted.effects"),layoutEffectsSymbol=Symbol("haunted.layoutEffects"),contextEvent="haunted.context";class State{constructor(t,e){this.update=t,this.host=e,this[hookSymbol]=new Map,this[effectsSymbol]=[],this[layoutEffectsSymbol]=[]}run(t){setCurrent(this);let e=t();return clear(),e}_runEffects(t){let e=this[t];setCurrent(this);for(let t of e)t.call(this);clear()}runEffects(){this._runEffects(effectsSymbol)}runLayoutEffects(){this._runEffects(layoutEffectsSymbol)}teardown(){this[hookSymbol].forEach(t=>{"function"==typeof t.teardown&&t.teardown()})}}const defer=Promise.resolve().then.bind(Promise.resolve());function runner(){let t,e=[];function s(){t=null;let s=e;e=[];for(var o=0,r=s.length;o<r;o++)s[o]()}return function(o){e.push(o),null==t&&(t=defer(s))}}const read=runner(),write=runner();class BaseScheduler{constructor(t,e){this.renderer=t,this.host=e,this.state=new State(this.update.bind(this),e),this[phaseSymbol]=null,this._updateQueued=!1}update(){this._updateQueued||(read(()=>{let t=this.handlePhase(updateSymbol);write(()=>{this.handlePhase(commitSymbol,t),write(()=>{this.handlePhase(effectsSymbol)})}),this._updateQueued=!1}),this._updateQueued=!0)}handlePhase(t,e){switch(this[phaseSymbol]=t,t){case commitSymbol:return this.commit(e),void this.runEffects(layoutEffectsSymbol);case updateSymbol:return this.render();case effectsSymbol:return this.runEffects(effectsSymbol)}}render(){return this.state.run(()=>this.renderer.call(this.host,this.host))}runEffects(t){this.state._runEffects(t)}teardown(){this.state.teardown()}}const toCamelCase=(t="")=>t.replace(/-+([a-z])?/g,(t,e)=>e?e.toUpperCase():"");function makeComponent(t){class e extends BaseScheduler{constructor(t,e,s){super(t,s||e),this.frag=e}commit(e){t(e,this.frag)}}return function(t,s,o){const r=(o||s||{}).baseElement||HTMLElement,{observedAttributes:n=[],useShadowDOM:u=!0,shadowRootInit:a={}}=o||s||{};class c extends r{static get observedAttributes(){return t.observedAttributes||n||[]}constructor(){super(),!1===u?this._scheduler=new e(t,this):(this.attachShadow({mode:"open",...a}),this._scheduler=new e(t,this.shadowRoot,this))}connectedCallback(){this._scheduler.update()}disconnectedCallback(){this._scheduler.teardown()}attributeChangedCallback(t,e,s){if(e===s)return;let o=""===s||s;Reflect.set(this,toCamelCase(t),o)}}const h=new Proxy(r.prototype,{getPrototypeOf:t=>t,set(t,e,s,o){let r;return e in t?(r=Object.getOwnPropertyDescriptor(t,e),r&&r.set?(r.set.call(o,s),!0):(Reflect.set(t,e,s,o),!0)):(r="symbol"==typeof e||"_"===e[0]?{enumerable:!0,configurable:!0,writable:!0,value:s}:function(t){let e=t,s=!1;return Object.freeze({enumerable:!0,configurable:!0,get:()=>e,set(t){s&&e===t||(s=!0,e=t,this._scheduler&&this._scheduler.update())}})}(s),Object.defineProperty(o,e,r),r.set&&r.set.call(o,s),!0)}});return Object.setPrototypeOf(c.prototype,h),c}}class Hook{constructor(t,e){this.id=t,this.state=e}}function use(t,...e){let s=notify(),o=current[hookSymbol],r=o.get(s);return r||(r=new t(s,current,...e),o.set(s,r)),r.update(...e)}function hook(t){return use.bind(null,t)}function createEffect(t){return hook(class extends Hook{constructor(e,s,o,r){super(e,s),t(s,this)}update(t,e){this.callback=t,this.values=e}call(){this.values&&!this.hasChanged()||this.run(),this.lastValues=this.values}run(){this.teardown(),this._teardown=this.callback.call(this.state)}teardown(){"function"==typeof this._teardown&&this._teardown()}hasChanged(){return!this.lastValues||this.values.some((t,e)=>this.lastValues[e]!==t)}})}function setEffects(t,e){t[effectsSymbol].push(e)}const useEffect=createEffect(setEffects);function setLayoutEffects(t,e){t[layoutEffectsSymbol].push(e)}const useLayoutEffect=createEffect(setLayoutEffects),useState=hook(class extends Hook{constructor(t,e,s){super(t,e),this.updater=this.updater.bind(this),"function"==typeof s&&(s=s()),this.makeArgs(s)}update(){return this.args}updater(t){if("function"==typeof t){const e=t,[s]=this.args;t=e(s)}this.makeArgs(t),this.state.update()}makeArgs(t){this.args=Object.freeze([t,this.updater])}}),useMemo=hook(class extends Hook{constructor(t,e,s,o){super(t,e),this.value=s(),this.values=o}update(t,e){return this.hasChanged(e)&&(this.values=e,this.value=t()),this.value}hasChanged(t=[]){return t.some((t,e)=>this.values[e]!==t)}}),useCallback=(t,e)=>useMemo(()=>t,e),useRef=t=>useMemo(()=>({current:t}),[]);function haunted({render:t}){return{component:makeComponent(t)}}const{component:hauntedComponent}=haunted({render:litRender});export{useState};export{useEffect};export{useLayoutEffect};export{useMemo};export{useCallback};export{useRef};export{hook};export{Hook};export{BaseScheduler};export{State};export const html=litHtml;export const render=litRender;export const component=hauntedComponent;export default haunted;;window.useState=useState;window.useEffect=useEffect;window.useLayoutEffect=useLayoutEffect;window.useMemo=useMemo;window.useCallback=useCallback;window.useRef=useRef;window.hook=hook;window.Hook=Hook;window.html=html;window.component=component;window.haunted=haunted;
